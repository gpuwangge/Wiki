# 简介
游戏引擎总是调用操作系统的API  
程序会编译生成资源文件，链接生成exe文件  
点击exe程序后，就会开始进程，也就是生成代码段，数据段，堆栈段，分配内存  
然后会找程序入口main函数  
exe就会变成数据加载入内存当中  
如果要看到图片，就要去内存中找到存图片的数据拿出来  
早期游戏开发需要操作硬件，比如驱动、控制显存，但现在不需要了  
举例：Unity的Input.GetKeyDown或UE的BindAxis本质都是使用windows的键盘消息WM_KEYDOWN和WM_KEYUP  
所以，只要能自己封装API(Windows, Vulkan)，就能自己做游戏引擎  
国内的游戏引擎程序员都是做系统这块的, 因此游戏开发也是系统级别的开发  

综上所述，要进行游戏开发有两个部分：系统API和图形API  
如果选择使用Windows系统，需要熟练掌握windows api的用法。包含windows.h头文件，使用int WINAPI WinMain(...)作为入口函数  
也可以使用glfw、sdl等包装好的库  
图形API一般可以选用跨平台的Vulkan。如果仅限于windows系统，也可以选directX  

另外，即使掌握了计算机图形学，也做不出来一个游戏引擎(只能做一个渲染模块)。  
游戏引擎可不止是一个渲染模块，还有输入输出，内存管理，消息循环等。  
反过来说，图形学也不是只关注渲染这一个模块。即使是渲染也不单单应用在游戏引擎上。  


# Windows编程小技巧
- Handle句柄：用处是找内存。比如，窗口句柄可以用来找窗口。    
- 黑客注射玩法：首先不能用.exe方式，而应该生成.dll文件。入口函数要修改(或者不需要入口函数)。  
搜索一个叫"DLL注入工具"的工具，它可以自动把自己写的.dll注入到某个正在运行的进程里。  
这样就没办法在进程管理器里面关闭.dll的函数了。  
高端的玩法是自动注射，就是自己写注射工具  
- .dll, .lib, .exe本质都是一样的：存翻译好的机器代码和数据。其主要区别是用法不同。.exe可以直接启动, .dll不能单独启动，需要依附其他程序，其他程序会记录dll函数的地址。  
.lib存粹是代码库，在编译的时候就嵌入.exe了。  
- Windows内核(kernel)、用户(User)和GDI，是Windows内部三个主要.dll。  
Kernel: WINBASE.H, 负责内存管理、文件输入输出和任务管理。ex: kernel32.dll  
User: WINUSER.H, 负责用户界面和窗口管理  
GDI: WINGDI.H, 负责图形设备接口或在打印机上显示文本和图形  
- 现代操作系统分层：底层是硬件，上层是软件(软件底层是内核态(操作系统)，软件上层是用户态，又分为用户接口和应用(Web浏览器，阅读器，播放器等))  
举例说说用户接口，比如windows里面是dos，linux里面是shell，可以控制其他的软件，相当于一个接口。
同时分层也是模糊的，有些软件可以跨好几层。  
- 关于windows系统级消息处理和普通消息处理的区别  
普通消息处理：A给B发消息，B处理完毕并反馈。  
系统级消息处理：A先把消息发给系统，系统把消息写入消息队列，B从消息队列中获得消息，再把消息Dispatch给系统，系统再执行消息。执行消息的具体做法由B通过回调函数定义。  
总而言之，系统不允许B直接处理A的消息。消息机制必须通过系统来调配。(系统扮演一个垂帘听政的角色)  
- 资源：比如菜单和文件。windows使用rc文件描绘资源。rc文件使用rc.exe生成。  
- JDI: Windows可以用JDI画图，比如:
```
PAINTSTRUCT ps = {0}; //创建画刷结构
HDC hdc = BeginPaint(hWnd, &ps); //创建画刷句柄   
SetPixel(hdc, 500, 500, RGB(255,0,0)); //画点
MoveToEx(hdc, 100, 100, NULL); //设置起点
LineTo(hdc, 500, 500); //画线
Rectanble(hdc, 0, 0, 100, 100); //画正方形，是一个封闭图形。如果用LineTo画的图形不能封闭。
HBRUSH hBrush=CreateSolidBrush(RGB(255,0,0)); //创建一个实心画刷，设置为红色
HDGIOBJ defaultBrush=SelectObject(hdc, hBrush);//将画刷hBrush应用到话刷句柄hdc中
Ecclipse(hdc, 0, 0, 100, 100); //画圆⚪，红色
SelectObject(hdc, defaultBrush); //把红色画刷换回默认普通白色画刷
DeleteObject(hBrush); //把红色画刷销毁
EndPaint(hWnd, &ps); //释放画笔
``` 

# 图形学小知识点
- 为什么显示器要有分辨率：目前的显示器都是光栅显示器，这种显示器的特点是一个以点阵组成的光源发生器。每一个点阵单元被称为一个像素(pixel)。  
光栅显示器的特点是不能直接画一条直线，只能用一系列像素去近似表示直线，除非这条直线是完全水平、竖直，或对角线的。  
点阵的长和宽方向的像素数量形成了分辨率。
比如，4k分辨率的显示器像素数为3840*2160=8294400，共829万个像素点。  


# Reference
- https://www.bilibili.com/video/BV1er4y1r7QK/  
- 毛星云<<逐梦旅程:Windows游戏编程之从零开始>>  
