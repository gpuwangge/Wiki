# 简介
游戏引擎总是调用操作系统的API  
程序会编译生成资源文件，链接生成exe文件  
点击exe程序后，就会开始进程，也就是生成代码段，数据段，堆栈段，分配内存  
然后会找程序入口main函数  
exe就会变成数据加载入内存当中  
如果要看到图片，就要去内存中找到存图片的数据拿出来  
早期游戏开发需要操作硬件，比如驱动、控制显存，但现在不需要了  
举例：Unity的Input.GetKeyDown或UE的BindAxis本质都是使用windows的键盘消息WM_KEYDOWN和WM_KEYUP  
所以，只要能自己封装API(Windows, Vulkan)，就能自己做游戏引擎  
国内的游戏引擎程序员都是做系统这块的, 因此游戏开发也是系统级别的开发  

综上所述，要进行游戏开发有两个部分：系统API和图形API  
如果选择使用Windows系统，需要熟练掌握windows api的用法。包含windows.h头文件，使用int WINAPI WinMain(...)作为入口函数  
也可以使用glfw、sdl等包装好的库  
图形API一般可以选用跨平台的Vulkan。如果仅限于windows系统，也可以选directX  

另外，即使掌握了计算机图形学，也做不出来一个游戏引擎(只能做一个渲染模块)。  
游戏引擎可不止是一个渲染模块，还有输入输出，内存管理，消息循环等。  
反过来说，图形学也不是只关注渲染这一个模块。即使是渲染也不单单应用在游戏引擎上。  

# 游戏循环
- 初始化
- 进入游戏循环
  - 读取玩家输入
  - 执行AI和游戏逻辑
  - 渲染下一帧：后缓存
  - 同步显示：后缓存->复制->主缓存
  - [退出]


# Windows编程小技巧
- Handle句柄：用处是找内存。比如，窗口句柄可以用来找窗口。    
- 黑客注射玩法：首先不能用.exe方式，而应该生成.dll文件。入口函数要修改(或者不需要入口函数)。  
搜索一个叫"DLL注入工具"的工具，它可以自动把自己写的.dll注入到某个正在运行的进程里。  
这样就没办法在进程管理器里面关闭.dll的函数了。  
高端的玩法是自动注射，就是自己写注射工具  
- .dll, .lib, .exe本质都是一样的：存翻译好的机器代码和数据。其主要区别是用法不同。.exe可以直接启动, .dll不能单独启动，需要依附其他程序，其他程序会记录dll函数的地址。  
.lib存粹是代码库，在编译的时候就嵌入.exe了。  
- Windows内核(kernel)、用户(User)和GDI，是Windows内部三个主要.dll。  
Kernel: WINBASE.H, 负责内存管理、文件输入输出和任务管理。ex: kernel32.dll  
User: WINUSER.H, 负责用户界面和窗口管理  
GDI: WINGDI.H, 负责图形设备接口或在打印机上显示文本和图形  
- 现代操作系统分层：底层是硬件，上层是软件(软件底层是内核态(操作系统)，软件上层是用户态，又分为用户接口和应用(Web浏览器，阅读器，播放器等))  
举例说说用户接口，比如windows里面是dos，linux里面是shell，可以控制其他的软件，相当于一个接口。
同时分层也是模糊的，有些软件可以跨好几层。  
- 关于windows系统级消息处理和普通消息处理的区别  
普通消息处理：A给B发消息，B处理完毕并反馈。  
系统级消息处理：A先把消息发给系统，系统把消息写入消息队列，B从消息队列中获得消息，再把消息Dispatch给系统，系统再执行消息。执行消息的具体做法由B通过回调函数定义。  
总而言之，系统不允许B直接处理A的消息。消息机制必须通过系统来调配。(系统扮演一个垂帘听政的角色)  
- 资源：比如菜单和文件。windows使用rc文件描绘资源。rc文件使用rc.exe生成。  
- GDI: Windows可以用GDI画图，比如:
```
PAINTSTRUCT ps = {0}; //创建画刷结构
HDC hdc = BeginPaint(hWnd, &ps); //创建画刷句柄   
SetPixel(hdc, 500, 500, RGB(255,0,0)); //画点
MoveToEx(hdc, 100, 100, NULL); //设置起点
LineTo(hdc, 500, 500); //画线
Rectanble(hdc, 0, 0, 100, 100); //画正方形，是一个封闭图形。如果用LineTo画的图形不能封闭。
HBRUSH hBrush=CreateSolidBrush(RGB(255,0,0)); //创建一个实心画刷，设置为红色
HDGIOBJ defaultBrush=SelectObject(hdc, hBrush);//将画刷hBrush应用到话刷句柄hdc中
Ecclipse(hdc, 0, 0, 100, 100); //画圆⚪，红色
SelectObject(hdc, defaultBrush); //把红色画刷换回默认普通白色画刷
DeleteObject(hBrush); //把红色画刷销毁
EndPaint(hWnd, &ps); //释放画笔
``` 

# 图形学小知识点
- 为什么显示器要有分辨率：目前的显示器都是光栅显示器，这种显示器的特点是一个以点阵组成的光源发生器。每一个点阵单元被称为一个像素(pixel)。  
光栅显示器的特点是不能直接画一条直线，只能用一系列像素去近似表示直线，除非这条直线是完全水平、竖直，或对角线的。  
点阵的长和宽方向的像素数量形成了分辨率。
比如，4k分辨率的显示器像素数为3840*2160=8294400，共829万个像素点。  
- Frame Buffer(帧缓存，显存，或叫显卡的内存)：频幕上每个像素点都对应帧缓存中的一组信息。我们在屏幕上看到的颜色就是frame buffer里的信息。直接修改frame buffer里面的值就可以在频幕上看到结果。  
- DDA(Digital Differential Analyzer)算法：是一种直线扫描算法(如何在显示器上画直线的算法，该“直线”其实是逼近的近似直线，理想直线不可能画出来)。要解决的问题是求出“直线”上每一个像素的坐标。  
直线方程：y=kx+b  
计算机做加法快，其他运算比如乘法都很慢。因为x的步长肯定是1，因此实际计算的是：
y_i+1 = k(x_i + 1) + b = y_i + k  
这样就把乘法变成加法了。  
如果k小于1，没问题；如果k大于1，可能出现y的值跳过好几个像素，视觉上不好看。一个解决方案是交换x，y的位置，把k变到1以下。  
因为y=kx+b无法表示一些直线，所以使用一般直线方程是Ax+By+C=0  

# DirectX
- DirectX和应用程序的关系：Application->DirectX->HAL->Device  
HAL(Hardware Abstract Layer)：硬件抽象层。系统Kernel只实现最底层的比如register读写操作，复杂的硬件相关的逻辑都放进了HAL里面，属于用户层，代码可以封闭。这样的好处是HAL的程序和参数可以保密。  
(系统内核代码，比如Linux内核，都是必须公开的)   
Driver和HAL的区别：Driver可以写在系统Kernel里，也可以写在HAL里，也可以跨两层。一般为了闭源保密会选择把逻辑写在HAL里，简单的open/read/write等操作写在kernel里。    
- 表面(Surface)：表面是个跟屏幕不同的概念。分为离屏表面和显示表面。计算图形的时候先是在离屏表面上绘制，然后以极高的速度将图像转入显示表面。  
这样的好处是对用户隐藏了擦除图像，生成显示等事情。  
一般把离屏表面(off-screen surface)称为后台缓存(back buffer)   
表面本质上是个数组。  
- 刷新频率：application的刷新频率f0未必跟显示器的刷新频率f1一致。  
如果f0<f1，并且不用surface，就会发现画面断断续续，画面一节一节出现。  
- 交换链是双缓冲的进阶版。有点类似接力赛。  
- 深度缓存：为了解决前后遮挡问题，把被遮挡的线或面进行消隐。  
深度缓存的算法：Z-Buffer算法  
- Vertex/Index Buffer: 使用Vertex/Index Buffer的好处是它可以存放在显存中，速度快。  
  

# Reference
- https://www.bilibili.com/video/BV1er4y1r7QK/  
- 毛星云<<逐梦旅程:Windows游戏编程之从零开始>>  
