# Memory存储原理
一个内存地址可以存储1个字节，或8位(bit)的数据, 或0~255（2^8=256）。  
(换句话说，每一个字节都有唯一的一个地址)  
原因是内存物理结构中的最小单元就是8 bit，因此系统会以此为依据进行管理。  
(其物理结构是8个物理单元串在一根地址线上，一次可以进行8bit的读写)  
一个内存条上面有若干个内存颗粒(chip)，每个颗粒上又有若干bank，每个bank上又有电容组成的二维矩阵。矩阵的每个元素就是内存的一个最小单位，其含有8个小电容。  

# Memory地址的表示
内存地址可以用16位，32位或64位表示。  
(当然也可以用任意位数，比如28, 40等)

比如0x0001表示某一个内存地址。(上面存储的内容大小为1个字节)   
一个16进制数字占用4个bit存储空间，四个16进制数字占用16 bit，储存的数据是8 bit。  
此外，该内存地址的寻址使用了16 bit(带宽=16，或者说是CPU用了16根地址线)。则说明在此系统下最大寻址空间为2^16=65536(个地址)。或65536/1024=64kb个地址。  

在32位系统下，寻址空间为2^32=4194304kb=4096mb=4gb个地址。  
意味着该系统的CPU需要至少32根地址线。需要8个hex数字才能表示一个地址。但每个地址存储的数据依旧是1个字节。  
举例：0x00000001  

在64位系统下，寻址空间为2^64=17179869184gb个地址。(基本可以理解为用不完了)   
同样，该系统的CPU需要至少64根地址线。需要16个hex数字才能表示一个地址。但每个地址存储的数据依旧是1个字节。  
举例：0x 00000000 00000001  

寄存器位数：在64位系统下，CPU同时有8，16，32和64位寄存器，这里的位数是指一个寄存器能存多大的数据，并不是地址的表示位数。  
以32位寻址和32位寄存器为例：一个数据占32bit，每一个内存地址存储的依旧是8bit，所以每个寄存器地址的间隔为4：  
0x 00000000  
0x 00000004  
0x 00000008  
0x 0000000d  
0x 00000010  
...

在内存文件里，通常第一列是内存地址，以冒号区隔，冒号右边的是内存数据。  
以下表示在一个32位寻址系统中，每一行有16个内存地址(0x04002010-0x04002000=16)，共可以存放16*8=128 bit的数据。  
这些数据以hex格式显示。一个hex需要4个bit存放，因此一共有128/4=32个hex数字，这些数字通常以8个(32位)为一组，共4组。  
04002000: 00000004 00000000 00000080 00000020  
04002010: 00000000 00000000 FFFFFFFF FFFFFFFF  
04002020: 00000600 00000000 00000000 00000000  
...

如果要往某个内存地址存数据，首先要获得内存地址的值，然后还有数据宽度(比如8, 16, 32或64位)。  

# Virtual Memory虚拟内存
## 虚拟内存原理
操作系统处理内存的时候，使用虚拟内存技术。采用这种技术时，每个进程仿佛自己独享一片2（N次方）字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为2（64次方） Byte。  

这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。  

由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫MMU（Memory Management Unit）的硬件完成。  

应用程序内部的虚拟地址在编译的时候已经由编译器指定了。  

应用程序读出来的变量的地址也是虚拟地址。总的来说，为了安全性，应用程序是不能直接访问物理地址的。  

## Page(页)
在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096 Byte（4K）。4096是2的12次方。  

所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：52bit的页号（高地址），跟12bit的页内偏移量（低地址）。  

## Page Fault
我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。这个机制把内存分为mapped和unmapped两部分。  

## 内存排布
以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，如前所述这么大的空间其实根本用不完的，Linux实际上只用了其中一小部分（256T=2^8*2^40 =2^48）。(T=>G=>M=>K)   
Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。  
最高17位为全0的时候，低位2^47是128T大小用作User Space。  
最高17位为全1的时候，同样有2^47高位128T大小作为Kernel space。  
所以，实际用到的地址为空间为   
0x0000000000000000 ~ 0x00007FFFFFFFFFFF    
和    
0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF    
其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。   

User Space内又分为(地址由高到低)  
Stack：栈  
Mapping Area：mmap系统调用相关的区域？  
Heap：堆  
BSS：未初始化过的全局变量  
Data：初始化过的全局变量  
Code: 编译之后的可执行机械代码指令  

# 内存对齐(Memory Alignment)
内存对齐（Memory Alignment）是指在计算机系统中，数据在内存中的存储地址需要满足特定的对齐要求。对齐要求通常是为了提高内存访问的效率，因为现代处理器在访问内存时，通常会以固定大小的块(块是指存储内容的大小)（如32位系统中4字节、64位系统中8字节等）为单位进行读取和写入操作。如果数据没有按照这些块的边界对齐，处理器可能需要进行额外的操作来访问数据，从而降低性能。  
例如：  
- 4字节块：处理器一次可以读取或写入4字节的数据。这意味着处理器可以在一个操作中处理一个32位的整数（4字节）。   
- 8字节块：处理器一次可以读取或写入8字节的数据。这意味着处理器可以在一个操作中处理一个64位的整数或一个双精度浮点数（8字节）。  

这种固定大小的块有助于提高内存访问的效率，因为处理器的内存总线和缓存通常是按照这些块大小设计的。如果数据对齐到这些块的边界上，处理器可以更高效地进行读取和写入操作。  
举个例子，如果一个32位的整数（4字节）存储在一个地址为0x1000的内存位置上，那么这个整数是对齐的，因为0x1000是4的倍数。如果这个整数存储在地址0x1001上，那么它就是未对齐的，处理器可能需要进行额外的操作来读取或写入这个整数，从而降低性能。  

假设我们有一个32位（4字节）的整数，并且我们希望它在内存中是4字节对齐的。这意味着它的地址必须是4的倍数  
```
int main() {
    int x;
    printf("Address of x: %p\n", (void*)&x);
    return 0;
}
```
在这个示例中，x 的地址应该是4的倍数。如果 x 的地址是 0x1004，那么它是4字节对齐的。如果 x 的地址是 0x1003，那么它不是4字节对齐的。  

在设计内存的时候，对齐是一个重要的考虑因素。实现内存对齐的参数如下：  
- 对齐单位(Alignment Unit): 指的是数据在内存中对齐的字节数。例如，4字节对齐意味着数据的地址必须是4的倍数。对齐单位通常跟处理器有关，比如32位处理器通常要求4字节对齐，64位处理器要求8字节对齐。(但不意味着处理器一次读取4或8字节数据)  
- 对齐边界(Alignment Boundary): 对齐边界是指数据存储的地址必须是对齐单位的倍数。例如，4字节对齐的边界是4的倍数地址，如0x0004、0x0008、0x000C等。
- 对齐大小(Alignment Size): 对齐大小是指在内存分配或数据存储时，调整后的数据大小，以满足对齐单位的要求。对齐大小通常是原始数据大小向上取整到最近的对齐单位的倍数。  

假如对齐单位是8字节，每个数据结构需要分配大小为13字节，则应该调整对齐大小为16字节。对齐边界依然是8字节的倍数。所以最后的地址举例为：  
0x0008, 0x001e, 0x0034...

下面代码说明了在给定对其单位ALIGNMENT(可以是2,4,8,16...)的时候，如何计算得到对齐大小  
```
size_t align_size(size_t size) {
    return (size + (ALIGNMENT - 1)) & ~(ALIGNMENT - 1);
}
```
上述代码中，& ~(ALIGNMENT - 1)的作用是清除掉低位的未对齐位数。比如ALIGNMENT=4的时候，清除掉0b11; ALIGNMENT=8的时候，清除掉0b111。  
(size + (ALIGNMENT - 1))的作用是把size前进到下一个对齐边界。  
举例(当ALIGNMENT=8)：  
size=5, 5+7=12(0b1100)，未对齐的部分0b100(4)会被清除，剩下0b1000(8)，也就是对齐大小是8。  
size=8, 8+7=15(0b1111)，未对齐的部分0b111(7)会被清除，剩下0b1000(8)，也就是对齐大小是8。  
size=13, 13+7=20(0b10100), 未对齐的部分0b100(4)会被清除，剩下0b10000(16)，也就是对齐大小是16。  


假如对齐单位是8字节，是不是意味着处理器在读取一次就是8字节数据呢？并不是。处理器一次读取的数据量取决于内存访问宽度。  
- 内存访问宽度(Memory Access Width): 决定了处理器一次读取或写入的最大数据量。内存访问宽度通常由处理器的总线宽度和缓存行大小决定。  

在定义结构体的时候，编译器会自动对齐结构体成员，以确保每个成员的地址都满足对齐要求。  
```
struct Example {
    char a;    // 1字节
    int b;     // 4字节
    short c;   // 2字节
};
```
在这个结构体中，编译器可能会在 a 和 b 之间插入填充字节（padding），以确保 b 的地址是4的倍数。  

在实现内存分配函数时，需要确保分配的内存块地址满足对齐要求。例如，malloc 函数通常会返回对齐到8字节或16字节边界的内存地址。  

# 如何实现自定义malloc函数


# 常用2进制位数和10进制size换算
2^8=256 (8位2进制可以表示10进制的256个数据:0~255)  
2^10=1024=1k  
2^16=65536  
2^20=1048576=1m=1e6  
2^22=4194304=4m=4e6  
2^30=1073741824=1g=1e9  
2^32=4294967296=4e9  
2^40=1t=1e12  
2^50=1e15  
2^52=4e15  
2^60=1e18  
2^64=2e19  


# MMU
MMU = Memory Management Unit  
MMU的主要作用是负责从CPU内核发出的虚拟地址(VA)到物理地址(PA)的映射，并提供硬件机制的内存访问权限检查。  
MMU使得每个用户进程拥有自己的地址空间，并通过内存访问权限的检查保护每个进程所用的内存不被其他进程破坏。  

# TLB
TLB = Translation Lookaside Buffer  
读取内存工作流程：输入是虚拟地址，首先查询页表获得物理地址，然后通过物理地址读取指令和数据。  
为了减少MMU导致的性能下降，使用了TLB作为地址转换缓冲器，或称“快表”。其原理是建立关于表页的cache。  
查询页表的时候，如果发现页表已经在TLB里面的时候，就可以省去做查询的那一步。  
TLB里存的一般是最可能被访问的页表。  


# 内存模型设计概论

假设64位架构，需要用地址存储数据。每个地址占64位，每个地址存8位数据。  
具体需求是一个GetPointer函数，它可以获得一个内存地址，并且可以往这个地址里读写某size大小的内容。  
```
char* GetPointer(uint64_t address);  
```
输入是uinit64_t类型，表示支持64位寻址  
输出是一个8位char类型的指针。C语言里指针本身就是64位的，这里char也可以是其他任何类型。  
用char的好处是，每次使用+1运算的时候，这个地址往前走1位(也就是跨了8个bit的数据)，这样就可以实现对每个内存地址的精确访问。  
如果使用32位int指针，每次+1运算地址往前走4位(跨了32个bit的数据)  
示例：  
```
char* ptr = memorySpace.GetPointer(1000);
```
这里获得了地址ptr，可以往这个地址里写数据。  
示例：  
```
*ptr=10;
```

假如不使用GetPointer()来转换地址，直接使用address行不行呢?其实是不行的。  
因为address是个虚拟地址，真实的内存地址是使用系统api创建的(比如new关键字)。  
无法直接往虚拟地址里写数据。  

假如对每一个虚拟address，都用new来创建一个真实内存地址，理论上可行，但是首先效率就不高。因为对每一个地址使用new本身是巨大的开销。  
假设创建bit size=12的内存页面，每一次GetPointer()的时候，如果address不存在，就使用new来一次创建2^12=4096个地址。  
这样后续如果继续使用同一页面的地址，就不用再用new来创建了。  
页的位数也要设置合适的值。如果太小，就需要频繁创建页面；如果太大，则容易造成浪费，并且page offset的长度也会变长(需要更多的位数存储address_lo)  

对于总共64位的寻址，page offset是12位，剩下的page index是52位。这样子的话GetPointer()的作用就是new一个52位的地址页面，每个页面的大小是4096就可以了。  
在代码里52位的这一段通常标记为address_hi,12位这段通常标记为address_lo。  

但这里还有另外一个问题。当调用GetPointer()的时候，需要去查看address_hi这个地址是不是已经被创建了。  
所以需要一个数组来存储已经创建的address_hi。该数组的每个节点需要存储一个真实内存地址(64bits=2^6)。  
这个数组容器内最大容量为2^52=4e15，总共就是2^58约等于3e17。  
考虑到1t=2^40,这里需要的最大容量为4096t，这已经远超过一般家用pc的最大内存了，内存溢出是必然的结局。  

理论上，我们不需要为所有的address_hi创建节点。我们可以选择仅为需要的address_hi创建节点。  
下面提供一个树状结构来搭建address_hi节点。  
首先把52分为30和22两层(这是一个举例，也可以按需要任意取值)。  
这样子的话，总长度52位的address_hi就被分成了30位的address_hi_lo和20位的address_hi_hi。  
第一层：address_hi_lo数组的最大容量为2^30=1e9=1g(这里不需要创建64位的真实内存地址，因为这个不是叶子节点),一个可以接受的大小。  
第二层：address_hi_hi数组的最大容量为2^22=4e6=4m,2^28=256m。  
整个树如果完整创建，总大小=2^58，其实跟上述数组做法是一样的。  
但重点是第二层其实不会在一开始被创建，仅仅在需要的时候才会创建。  
这个树的层次也可以更多层，这样一开始的花销就更少了。  

是不是可以用hashtable而不是tree来创建？  
map的实现方法是红黑树，查找快，插入和删除慢。unordered_map的实现方法是hashtable+bucket，但每个bucket仍旧是链表或红黑树。  
因此hashtable可以看作一个tree的升级版本。  

# 内存模型设计实例
Input: uint64_t address  
Output: a pointer (char*)  
page_offset_size: 页偏移的bit位数  
total_address_size: 地址bit宽度，比如64  
level: 地址非偏移部分(页表)被分成好几个级别  

## 流程
首先把address分成address_hi和address_lo   
address_lo就是offset，不动  
address_hi向右移>>page_offset_size  
对address_hi查快表(TLB)获得new_address_hi  
return new_address_hi+address_lo  
如果快表没有查到，则需要进行PageTableWalk获得new_address_hi

### PageTableWalk
内存模型是一个树状结构，上面有很多node，其中第一个是root  
每个node都有一个pNode指针可以指向任何一个node数组，还有一个page指针(一个page就是一块以字节char为单元的内存)  
通常用union来定义node，因为node指针如果指向其他node，page指针就应该是空的(即这个node是枝干节点) ；若有page指针不空则说明它的node指针是空的(即这个node是叶子节点)  
这个树的层数就是level+1  
Walk的过程就是从root开始一层一层深度遍历(次数=level)，如果发现某一层的node是枝干，就调用CreateNode来生成它的下一层枝干节点（一个node数组）  
(CreateNode会生成一个size为2^current_level_bit的Node数组)  
等遍历结束后会到达一个叶子节点，如果这个叶子有page，就返回page。如果这个叶子也是枝干(意味着它是刚刚生成的)，就为他CreatePage并返回。  
(CreatePage会生成一个size为2^page_size_bit的char数组)  
(在这个模型里，只有遍历walk到的node array会被生成；且最多只有一个page会被生成；模型的level和每个level的size是由使用者设计的，层数少速度快，层数多浪费的空间少，都有优点)  

# Reference
https://www.cnblogs.com/alantu2018/p/9000777.html  


